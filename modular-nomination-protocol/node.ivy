#lang ivy1.7

include set

# id_t is the type of node ids
# self_id is the id_t of each node instance
# val_t is the type of values

module node(id_t, self_id, val_t) = {

    instance nset : set(id_t)

    # Interface of a node -- only define ways node can be called here.
    object intf = {
        # Node can be called from application
        # and asked to begin voting on something.
        action vote_for(value:val_t)

        # Node can also be called from network
        # and told that someone else voted or accepted.
        action recv_vote(src:id_t, value:val_t)
        action recv_accept(src:id_t, value:val_t)

        relation is_quorum_slice(S:nset)
        action add_quorum_slice(qslice:nset)

        after init {
            is_quorum_slice(S) := false;
        }
    }
    relation is_my_quorum(Q:nset)
    definition is_my_quorum(Q) =
        nset.member(self_id, Q) &
        forall OTHER .  nset.member(OTHER, Q) ->
            (exists SLICE . nodes(OTHER).intf.is_quorum_slice(SLICE) & nset.subset(SLICE, Q))

    # Logical specs for the interface -- use ghost variables here to track
    # logical changes to node's knowledge and state over time. These may
    # also be observed by other modules and other node instances.
    object spec = {
        relation heard_vote(SRC:id_t, VALUE:val_t)
        relation heard_accept(SRC:id_t, VALUE:val_t)

        relation have_voted(VALUE:val_t)
        relation have_accepted(VALUE:val_t)
        relation have_confirmed(VALUE:val_t)
        relation have_candidate_value

        after init {
            heard_vote(ID, VAL) := false;
            heard_accept(ID, VAL) := false;
            have_voted(VAL) := false;
            have_accepted(VAL) := false;
            have_confirmed(VAL) := false;
            have_candidate_value := false;
        }

        before intf.vote_for {
            require ~have_voted(value);
            require ~have_candidate_value;
        }

        after intf.vote_for {
            have_voted(value) := true;
            call net.intf.broadcast_vote(self_id, value);
        }

        before intf.recv_vote {
            require net.spec.have_delivered_vote(src, self_id, value)
        }

        after intf.recv_vote {
            heard_vote(src, value) := true;
            if (exists Q. is_my_quorum(Q) &
                forall OTHER . nset.member(OTHER, Q)
                    -> (heard_vote(OTHER, value) | heard_accept(OTHER, value))) {
                # accept condition 1
                have_accepted(value) := true;
                heard_accept(self_id, value) := true;
            };
            # TODO: accept condition 2
            if (exists Q. is_my_quorum(Q) &
                forall OTHER . nset.member(OTHER, Q)
                    -> heard_accept(OTHER, value)) {
                # Confirm
                have_confirmed(value) := true;
                have_candidate_value := true;
            };
        }

        before intf.add_quorum_slice {
            require nset.member(self_id, qslice);
        }


        after intf.add_quorum_slice {
            intf.is_quorum_slice(qslice) := true;
        }
    }

    # Implementation of the interface matching the logical specs -- use concrete
    # variables here to implement the interface defined and spec'ed above. These
    # should not be observed outside the current node.
    object impl = {

        # Include any state variables that would actually show up in
        # an implementation but we don't want to include in the spec.
        # individual voted : bool
        implement intf.vote_for {
        }
    }
}

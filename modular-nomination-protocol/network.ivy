#lang ivy1.7

include set

module network(id_t, val_t) = {


    object intf = {
        # Network can be called src a node sending a message.
        action broadcast_vote(src:id_t, value:val_t)
        action broadcast_accept(src:id_t, value:val_t)

        # Network can also be "called" spontaneously to note the
        # delivery of a message at a node.
        action deliver_vote(src:id_t, dst:id_t, value:val_t)
        action deliver_accept(src:id_t, dst:id_t, value:val_t)

        instance nset : set(id_t)
        relation is_quorum(S:nset)

        # Two quorums must intersect
        axiom forall S1, S2. (is_quorum(S1) & is_quorum(S2))
                -> (exists V. nset.member(V, S1) & nset.member(V, S2))

        # A quorum must not be empty
        axiom forall S . is_quorum(S) -> (exists V. nset.member(V, S))

        relation is_blocking(V:id_t, B:nset)

        definition is_blocking(V, B) =
            forall QUORUM . is_quorum(QUORUM) & nset.member(V, QUORUM)
                                -> exists W . nset.member(W, B) & nset.member(W, QUORUM)
    }

    object spec = {
        relation have_broadcast_vote(SRC:id_t, VALUE:val_t)
        relation have_broadcast_accept(SRC:id_t, VALUE:val_t)
        relation have_delivered_vote(SRC:id_t, DST:id_t, VALUE:val_t)
        relation have_delivered_accept(SRC:id_t, DST:id_t, VALUE:val_t)

        after init {
            have_broadcast_vote(SRC, VALUE) := false;
            have_broadcast_accept(SRC, VALUE) := false;
            have_delivered_vote(SRC, DST, VALUE) := false;
            have_delivered_accept(SRC, DST, VALUE) := false;
        }

        before intf.broadcast_vote {
            require nodes(src).spec.have_voted(value);
        }
        after intf.broadcast_vote {
            have_broadcast_vote(src, value) := true
        }

        before intf.deliver_vote {
            require have_broadcast_vote(src, value);
            # Remove this next condition to allow message duplication.
            require ~have_delivered_vote(src, dst, value);
        }
        after intf.deliver_vote {
            call nodes(dst).intf.recv_vote(src, value);
            spec.have_delivered_vote(src, dst, value) := true;
        }

        #######
        ####### ***INVARIANT***
        #######

        # If the networks has delivered a vote on VALUE from SRC to DST,
        # then SRC must have voted for VALUE.
        invariant have_delivered_vote(SRC, DST, VALUE) -> nodes(SRC).spec.have_voted(VALUE)

        # If ID accepts VALUE,
        # then there must exist at least one node that has voted for VALUE.
        invariant nodes(ID).spec.have_accepted(VALUE) ->
                    exists OTHER. nodes(OTHER).spec.have_voted(VALUE)
    }

    object impl = {
        relation something_private(X:id_t)
        implement intf.broadcast_vote {
            something_private(src) := true
        }
        implement intf.deliver_vote {
            something_private(src) := true
        }
    }
}
